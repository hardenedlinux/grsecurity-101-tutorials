"I understand. In death, a member of Project Mayhem has a name. His name is Robert Paulson...His name is Robert Paulson." --- Fight Club

## DRAM attacks

Dynamic Random Access Memory (DRAM) is a crucial component in modern computing. The recent exploitations such as BADRAM, BatteringRAM, and tee.fail have emerged as significant concerns for both security researchers and hardware manufacturers, revealing critical weaknesses in DRAM security. Those research revealed that the cost of DIMM interposers has seen a dramatic decline, dropping from $17,000 to $1,000 and even less than $50. This shift not only encourages more widespread experimentation with these attacks but also raises questions about the effectiveness of current DRAM security measures. Understanding these vulnerabilities and their implications on security is essential as we design future systems. BatteringRAM is an amazing research that successfully achieves key extraction without tampering with SPD data or memory training data, such as the MRC cache in x86 architectures. This is accomplished through the innovative use of dynamic memory aliasing. We must build the threat model cautionsly, otherwise things will ended up badly in "Someone else's computer".


| Attack                      | DRAM interposer                                                | Attack path | Mitigation |
|:---------------------------:|:--------------------------------------------------------------:|:------------:|:-----------:|
| [BadRAM](https://badram.eu/)| [RPI Pico based](https://github.com/badramattack/badram), ~$10 | **Preparation: Manipulate Memory Configuration to Create Aliases** <br> * The attacker targets the Serial Presence Detect (SPD) chip on a DDR4 or DDR5 memory module, which stores metadata like memory size and addressing (e.g., row/column bits).<br>* By altering this metadata (e.g., reporting more rows than physically exist), the system's BIOS is tricked into configuring the memory controller with an inflated view of the module's capacity (e.g., doubling it).<br>* This introduces "ghost" address bits that the DIMM ignores, causing aliasing: two different physical addresses now point to the same DRAM location.<br>* The system boots with this misconfiguration, but the attacker reserves the "ghost" memory regions (e.g., via OS parameters) to maintain stability.<br>- **Outcome**: Aliases are now available, invisible to the CPU's memory controller, allowing bypass of access controls.<br>**Exploitation: Break SEV-SNP Memory Integrity Using Aliases**<br>* SEV-SNP relies on the Reverse Map Table (RMP) for integrity: it tracks page ownership (guest vs. hypervisor) and mappings to prevent tampering or remapping.<br>* The attacker identifies aliases for protected memory pages (e.g., via a one-time scan of the address space).<br>**Using an alias:**<br>* Layout Integrity Break: The attacker modifies RMP entries (e.g., swaps mappings) through the alias, bypassing hardware write protections. This re-enables page-remapping attacks (e.g., similar to prior "SEVered" techniques), allowing arbitrary redirection of VM memory.<br>* Content Integrity Break: The attacker reads/writes ciphertexts via the alias (which appears hypervisor-owned). Since SEV-SNP uses AES-XEX (no built-in integrity/freshness), this enables:<br>** Ciphertext corruption (randomizes plaintext, useful for faults).<br>** Ciphertext replay (restores old values to the same address, as tweaks are address-based).<br>** These primitives undermine SEV-SNP's core claim: a VM reading its memory always gets what it last wrote.             |  [MRC cache measurement for coreboot](https://github.com/coreboot/coreboot/commit/b5581d556bf15bf5e064875ea6ba0d61895e0096) proposed by HardenedVault            |
| [BatteringRAM](https://batteringram.eu/)| [Open hardware](https://github.com/batteringramattack/batteringram), ~$50 | * A low-cost interposer (built from off-the-shelf parts) is physically placed between the CPU and a DDR4 memory module (DIMM). It uses simple switches to manipulate specific address lines (e.g., row bits A11 and A13) on the command/address bus.<br>* Dynamic Activation: The interposer is controlled by a microcontroller and only activated at runtime (post-boot), creating temporary "aliases" where two different system addresses map to the same physical DRAM location. This is deterministic and avoids affecting boot-time memory training or SPD data.<br>* Software Control: The attacker uses privileged access to manage memory allocation (e.g., via modified drivers or kernel parameters) to position victim and attacker data in aliasing locations.<br>**Bypassing Mitigations**: Boot-time alias checks pass because aliases aren't present during boot. Runtime activation evades detection.<br>* Attack Path on Intel Scalable SGX/AMD SEV-NP (Section 5: Arbitrary Plaintext Access and Provisioning Key Extraction)<br>* This attack exploits Scalable SGX's use of a single encryption key (via Total Memory Encryption - TME) for all enclave memory, combined with deterministic encryption (AES-XTS with address tweaks). The goal is to read/write plaintext in victim enclaves and extract the hardware provisioning key, breaking remote attestation.      |  * Intel TDX re-introudces 28-bit MAC in ECC bits against partial replay     |
| [TEE.fail](https://tee.fail/)| Customized, ~$1,000                                          | * Slow down the server's DDR5 memory speed via BIOS (to 3200 MT/s) for easier signal capture—doesn't affect TEE trust.<br>* Build/insert a cheap "interposer" (a small PCB with wires) between one memory module (DIMM) and the motherboard. Connect it to a logic analyzer (off-the-shelf device) to monitor encrypted memory traffic (ciphertexts) on one channel.<br>* root access on a GNU/Linux system.<br>* Reverse-engineer physical address mappings (via sysfs) to identify the physical address's DIMM location.<br>* Control TEE execution: Pause/resume code at key points (e.g., via page faults) and flush caches to ensure data hits the memory bus, syncing captures with the analyzer.<br>* Trigger a TEE operation (e.g., ECDSA signing in Intel's PCE enclave) and observe ciphertexts of intermediate values.<br>* Map observed ciphertexts back to plaintext (using test writes) to reconstruct secrets like the Provisioning Certification Key (PCK) or ECDSA nonces.<br>* Use extracted keys to sign fake "trusted" reports—e.g., pretend untrusted code is running in a secure TEE, or "borrow" NVIDIA GPU attestations.<br> **Exploit in Real Systems**: Apply to apps: E.g., join blockchain networks (like BuilderNet) to steal secrets/frontrun transactions, or fake secure AI workloads on GPUs.<br>**Outcome**: Breach confidentiality/integrity without detection.              | [MRC cache measurement for coreboot](https://github.com/coreboot/coreboot/commit/b5581d556bf15bf5e064875ea6ba0d61895e0096)              |